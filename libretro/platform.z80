        include 'nabu_macros.z80'
;===============================================================================
; VARIABLES, ENUMS AND IO PORTS
;===============================================================================
io_tmsdata:             equ 0x80
io_tmslatch:            equ 0x81

io_aydata:              equ 0xB1
io_aylatch:             equ 0xB0

joy0:                   equ 0xa8
joy1:                   equ 0xa9

joy_map_left:           equ %00000100
joy_map_right:          equ %00100000
joy_map_up:             equ %10000000
joy_map_down:           equ %01000000
joy_map_button:         equ %00000001

joy_status:             ds 2

;===============================================================================
; CP/M Get Key press
; INPUT: void
; OUTPUT: ascii of pressed key in A
; CLOBBERS: BC, DE
;===============================================================================
getk:
        ld      c,bdos_conio
        ld      e,0xff
        call    bdos_call
        ret

;===============================================================================
; Check if a key was pressed
; INPUT: void
; OUTPUT: A = 1 when a key is pressed, A = 0 when no key pressed.
; CLOBBERS: IY
;===============================================================================
is_key_pressed:
        in      a,(0x32)        ; read sio control status byte
        and     1               ; check the rcvr ready bit
        ret

;===============================================================================
; Gets latest character entered.  DOES NOT BLOCK ON RETRO
; INPUT: void
; OUTPUT: Ascii value of key in A
; CLOBBERS: IY, BC
;===============================================================================
get_char:
        in    a,(0x30)          ; read sio control data byte
        ret

;===============================================================================
; Returns the Joystick Status that can be matched against the Joystick enums
; defined at the beginning of this file.
; INPUT: A 0 = joy0, !0 = joy1
; OUTPUT: joy_status
; CLOBBERS: none
;===============================================================================
get_joy_status:
        or      a
        jr      z,.getJoy0
.getJoy1:
        in      a,(joy1)
        xor     0xff
        ld      (joy_status+1),a
        ret
.getJoy0:
        in      a,(joy0)
        xor     0xff
        ld      (joy_status+0),a
        ret

;===============================================================================
; Wait for the VDP VSYNC status to appear on the status register
; INPUT: void
; OUTPUT: void
; CLOBBERS: AF
;===============================================================================
tms_wait:
        in      a,(joy0)        ; read the /INT status via bodge wire 
        and     0x02            ; check U6, pin 4 (D1)
        jp      nz,tms_wait
        in      a,(io_tmslatch) ; read the VDP status register to reset the IRQ
        ret

;===============================================================================
; Read a register from the AY-3-8910
; INPUT: A = Register to read
; OUTPUT: A = value
; CLOBBERS: AF
;===============================================================================
ay_read:
        out     (io_aylatch),a
        in      a,(io_aydata)
        ret

;===============================================================================
; Write a value to the AY-3-8910 register
; INPUT: B = Register to write to, C = value to write
; OUTPUT: void
; CLOBBERS: none
;===============================================================================
ay_write:
        ld      a,b
        out     (io_aylatch),a
        ld      a,c
        out     (io_aydata),a
        ret

;===============================================================================
; Turn off all sound output
;===============================================================================
ay_all_off:
        ay_set_mixer AY_MIX_ALL_OFF
        ret

;===============================================================================
; Play note
; INPUT: B  = Channel to play on 0 = A, 1 = B, 2 = C
;        DE = Delay
;        HL = Note to play is an index into the ay_notes data table
; OUTPUT: void
; CLOBBERS: 
;===============================================================================
ay_play_note_delay:
        push    de
        push    bc
        ay_set_mixer AY_MIX_TONE_A&AY_MIX_TONE_B&AY_MIX_TONE_C
        pop     bc
.play_note:
        ld      a,b
        add     a,a             ; register pair - so need to double it. 0, 2, 4
        ld      b,a
        ld      de,ay_notes
        add     hl,hl           ; double HL because of length of each array
        add     hl,de           ; get pointer into ay_notes
        inc     hl              ; increment the pointer into fine value
        ld      c,(hl)          ; load fine value 

        call    ay_write

        dec     hl              ; increment pointer for course value
        ld      c,(hl)          ; get cource value
        inc     b               ; select course register
        call    ay_write
        pop     de
        ld      b,AY_ENVELOPE_F
        ld      c,e
        call    ay_write        ; fine period
        ld      b,AY_ENVELOPE_C
        ld      c,d             ; course period
        call    ay_write
        ay_set_env_shape AY_ENV_SHAPE_DECAY
        ret

;===============================================================================
; Play noise
; INPUT: B  = Channel to play on 0 = A, 1 = B, 2 = C
;        DE = Delay
;        HL = Noise period to play is an index into the ay_notes data table
; OUTPUT: void
; CLOBBERS: 
;===============================================================================
ay_play_noise_delay:
        push    de
        push    bc

        ay_set_mixer AY_MIX_NOISE_C
        ; fall through
.play_noise:
        pop     bc
        ld      c,l             ; load noise period
        call    ay_write
        ay_set_env_shape AY_ENV_SHAPE_DECAY
        pop     de
        ld      b,AY_ENVELOPE_F
        ld      c,e
        call    ay_write        ; fine period
        ld      b,AY_ENVELOPE_C
        ld      c,d             ; course period
        call    ay_write
        ret

        ;===============================================================================
        ; Stub functions that can't be done on the retro
        ;===============================================================================
init:
        ay_set_mixer AY_MIX_ALL_OFF&AY_MIX_TONE_A&AY_MIX_TONE_B&AY_MIX_TONE_C
        ay_set_volume AY_VOLUME_A 0 1
        ay_set_volume AY_VOLUME_B 0 1
        ay_set_volume AY_VOLUME_C 0 1
        ay_set_env_shape AY_ENV_SHAPE_DECAY
        ret

        include 'ay_3_8910_constants.z80'
        include 'ay_notes.z80'
